name: Branch maintenance (repair all branches)

on:
  schedule:
    - cron: "17 2 * * *" # nightly UTC
  workflow_dispatch:
    inputs:
      max_branches:
        description: "Max branches to process (0 = all)"
        required: false
        default: "0"
      include_patterns:
        description: "Comma-separated glob patterns (e.g. feature/*,fix/*). Empty=all"
        required: false
        default: ""
      exclude_patterns:
        description: "Comma-separated glob patterns (e.g. dependabot/*,autofix/*)."
        required: false
        default: "dependabot/*,autofix/*,repair/*"

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: branch-maintenance
  cancel-in-progress: false

env:
  CI: "true"
  TZ: "UTC"
  BASE_BRANCH: "main"
  MAX_AUTOFIX_ATTEMPTS: "2"

jobs:
  maintenance:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout base (full history)
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: "20"
          cache: "npm"

      - name: Install deps (base)
        run: npm ci

      - name: List and select branches
        id: branches
        shell: bash
        run: |
          set -euo pipefail
          git fetch --all --prune

          max="${{ inputs.max_branches }}"
          inc="${{ inputs.include_patterns }}"
          exc="${{ inputs.exclude_patterns }}"

          # Normalize patterns
          IFS=',' read -r -a INC <<< "${inc}"
          IFS=',' read -r -a EXC <<< "${exc}"

          # Collect origin branches (strip origin/)
          mapfile -t ALL < <(git for-each-ref --format='%(refname:short)' refs/remotes/origin | sed 's#^origin/##' | grep -v '^HEAD$' | sort)

          match_any() {
            local b="$1"; shift
            local -a pats=("$@")
            if [ "${#pats[@]}" -eq 0 ] || [ -z "${pats[0]}" ]; then
              return 0
            fi
            for p in "${pats[@]}"; do
              [ -z "$p" ] && continue
              if [[ "$b" == $p ]]; then return 0; fi
            done
            return 1
          }

          excluded() {
            local b="$1"; shift
            local -a pats=("$@")
            for p in "${pats[@]}"; do
              [ -z "$p" ] && continue
              if [[ "$b" == $p ]]; then return 0; fi
            done
            return 1
          }

          # Select branches: include filters then exclude filters
          SEL=()
          for b in "${ALL[@]}"; do
            if excluded "$b" "${EXC[@]}"; then
              continue
            fi
            if match_any "$b" "${INC[@]}"; then
              SEL+=("$b")
            fi
          done

          # Remove base branch from list if present
          TMP=()
          for b in "${SEL[@]}"; do
            if [ "$b" != "${BASE_BRANCH}" ]; then TMP+=("$b"); fi
          done
          SEL=("${TMP[@]}")

          # Cap if requested
          if [ "${max}" != "0" ] && [ "${#SEL[@]}" -gt "${max}" ]; then
            SEL=("${SEL[@]:0:${max}}")
          fi

          # Output as newline list (safe for bash loop)
          printf "%s\n" "${SEL[@]}" > branches.txt
          echo "count=${#SEL[@]}" >> "$GITHUB_OUTPUT"
          echo "Selected ${#SEL[@]} branches:"
          cat branches.txt

      - name: Repair branches (create PRs)
        if: steps.branches.outputs.count != '0'
        env:
          GH_TOKEN: ${{ secrets.NEXIFYAI_BOT_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          # Ensure gh available (GitHub-hosted runners have it)
          gh --version >/dev/null

          date_tag="$(date -u +%Y%m%d)"
          base="${BASE_BRANCH}"

          # Helper: open PR if not exists, else update
          upsert_pr() {
            local head="$1"
            local base="$2"
            local title="$3"
            local body="$4"

            # If PR exists, just comment/update title/body (body update is best-effort).
            if gh pr view "$head" --json number >/dev/null 2>&1; then
              local n
              n="$(gh pr view "$head" --json number -q .number)"
              gh pr edit "$n" --title "$title" --body "$body" >/dev/null 2>&1 || true
              echo "$n"
              return 0
            fi

            gh pr create --head "$head" --base "$base" --title "$title" --body "$body" --label "maintenance" -f
            gh pr view "$head" --json number -q .number
          }

          while IFS= read -r br; do
            echo "----"
            echo "Processing branch: $br"

            # Create repair branch off the remote branch
            git checkout -B "repair/${br//\//-}/${date_tag}" "origin/$br"

            # Merge base into repair to reduce drift (no rebase / no force)
            git fetch origin "$base":"origin/$base"
            if ! git merge --no-edit "origin/$base"; then
              echo "Merge conflict when merging $base into $br. Creating needs-human PR."
              git merge --abort || true

              # Create PR that signals conflict (no code change)
              title="fix(branch): repair $br (merge conflict with $base)"
              body=$'Automated branch repair could not merge base branch due to conflicts.\n\nAction needed:\n- Checkout repair branch and resolve merge conflicts.\n- Re-run CI.\n\nThis PR was created automatically.'
              # Push branch (even without merge) for humans to resolve
              git push -u origin "HEAD" || true
              prn="$(upsert_pr "repair/${br//\//-}/${date_tag}" "$base" "$title" "$body")"
              gh pr edit "$prn" --add-label "needs-human" >/dev/null 2>&1 || true
              continue
            fi

            # Run fast checks locally to catch obvious issues quickly (full gate will run in CI)
            mkdir -p logs
            set +e
            npm run security:scan-secrets | tee "logs/${br//\//-}.secret.log"
            sec_rc=${PIPESTATUS[0]}
            npm run lint | tee "logs/${br//\//-}.lint.log"
            lint_rc=${PIPESTATUS[0]}
            npm run type-check | tee "logs/${br//\//-}.type.log"
            type_rc=${PIPESTATUS[0]}
            npm run build | tee "logs/${br//\//-}.build.log"
            build_rc=${PIPESTATUS[0]}
            set -e

            # If local checks fail, we still create the PR to trigger autofix loop from CI.
            # Push repair branch
            git push -u origin "HEAD"

            # Create/update PR to BASE (main)
            title="fix(branch): repair $br (sync with $base)"
            body=$'Automated branch maintenance:\n- Merged base branch into this repair branch.\n- Ran local fast checks (logs attached in CI).\n\nIf CI fails, autofix workflow may open/update an autofix PR.\n\nOriginal branch: '"$br"$'\nBase: '"$base"$'\n'
            prn="$(upsert_pr "repair/${br//\//-}/${date_tag}" "$base" "$title" "$body")"

            # Label needs-human if forbidden-path changes appear (guardrail)
            if git diff --name-only "origin/$br"...HEAD | grep -E '^(prisma/migrations/|supabase/migrations/|\.env|\.env\.|\.env/|\.vercel/)' >/dev/null 2>&1; then
              gh pr edit "$prn" --add-label "needs-human" >/dev/null 2>&1 || true
            fi

            # Optional: if local checks passed, add label
            if [ "$sec_rc" -eq 0 ] && [ "$lint_rc" -eq 0 ] && [ "$type_rc" -eq 0 ] && [ "$build_rc" -eq 0 ]; then
              gh pr edit "$prn" --add-label "autobuild-ok" >/dev/null 2>&1 || true
            fi

          done < branches.txt

      - name: Upload maintenance logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: branch-maintenance-logs
          path: logs/
