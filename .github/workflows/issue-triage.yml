# Issue Triage: Auto-Labeling, Auto-Assign, Repro-Check (Auftrag 21)
name: issue-triage

on:
  issues:
    types: [opened, edited, reopened, labeled]

permissions:
  issues: write

jobs:
  triage:
    name: Auto-Triage Issue
    runs-on: ${{ vars.RUNNER || 'ubuntu-latest' }}
    if: github.event.issue.pull_request == null
    steps:
      - name: Auto-label based on content
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const title = (issue.title || '').toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const text = title + ' ' + body;
            const existingLabels = issue.labels.map(l => l.name);

            const labelsToAdd = [];

            // Content-based labels
            const rules = [
              { pattern: /\[bug\]|bug|fehler|crash|broken|kaputt/, label: 'type:bug' },
              { pattern: /\[feature\]|feature|enhancement|verbesserung|wunsch/, label: 'type:feature' },
              { pattern: /doc(s|umentation)|readme|wiki|dokumentation/, label: 'docs' },
              { pattern: /ci|workflow|pipeline|github.actions|deploy/, label: 'ci' },
              { pattern: /security|vulnerability|cve|sicherheit|audit/, label: 'security' },
              { pattern: /database|migration|prisma|supabase|rls/, label: 'db' },
              { pattern: /ai|deepseek|nscale|model|llm/, label: 'ai' },
              { pattern: /critical|urgent|production|outage|dringend/, label: 'priority:high' },
            ];

            for (const rule of rules) {
              if (rule.pattern.test(text) && !existingLabels.includes(rule.label)) {
                labelsToAdd.push(rule.label);
              }
            }

            // Ensure labels exist and add them
            for (const label of labelsToAdd) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                });
              } catch {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                  color: 'ededed',
                });
              }
            }

            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labelsToAdd,
              });
            }

      - name: Auto-assign to default maintainer
        if: github.event.action == 'opened'
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            // Only assign if no one is assigned yet
            if (issue.assignees && issue.assignees.length > 0) return;

            // Assign to repo owner as default maintainer
            const owner = context.repo.owner;
            try {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                assignees: [owner],
              });
            } catch (e) {
              core.info(`Could not auto-assign: ${e.message}`);
            }

      - name: Check for required fields (repro/logs)
        if: github.event.action == 'opened' || github.event.action == 'edited'
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const labels = issue.labels.map(l => l.name);

            // Only check bug reports
            const isBug = labels.includes('type:bug') || issue.title.toLowerCase().includes('[bug]');
            if (!isBug) {
              // For non-bugs, mark ready-for-dev if has required content
              if (body.trim().length > 20) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: ['ready-for-dev'],
                  });
                } catch {}
              }
              return;
            }

            const missing = [];

            // Check repro steps
            if (!/reproduction|repro|steps to reproduce|schritte/i.test(body) &&
                !/1\.\s+\S/.test(body)) {
              missing.push('Reproduction steps');
            }

            // Check expected/actual
            if (!/expected|erwartet/i.test(body)) {
              missing.push('Expected behavior');
            }
            if (!/actual|tatsÃ¤chlich|aktuell/i.test(body)) {
              missing.push('Actual behavior');
            }

            if (missing.length > 0) {
              // Add needs-info label
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'needs-info',
                });
              } catch {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'needs-info',
                  color: 'fbca04',
                  description: 'Waiting for more information from reporter',
                });
              }

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['needs-info'],
              });

              const checklist = missing.map(m => `- [ ] ${m}`).join('\n');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `ðŸ‘‹ Thanks for reporting! The following information is missing:\n\n${checklist}\n\nPlease update the issue with the missing details so we can investigate.`,
              });
            } else {
              // All required fields present â€” mark ready
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'needs-info',
                });
              } catch {}

              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'ready-for-dev',
                });
              } catch {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'ready-for-dev',
                  color: '0e8a16',
                  description: 'Issue has all required info and is ready for development',
                });
              }

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['ready-for-dev'],
              });
            }
