# Issue Triage: Auto-Labeling, Auto-Assign, Repro-Check + OpenClaw Bot Analyse
name: issue-triage

on:
  issues:
    types: [opened, edited, reopened, labeled]

permissions:
  issues: write

jobs:
  triage:
    name: Auto-Triage Issue
    runs-on: ${{ vars.RUNNER || 'ubuntu-latest' }}
    if: github.event.issue.pull_request == null

    steps:
      - name: Auto-label based on content
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = (issue.title || '').toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const text = title + ' ' + body;
            const existingLabels = issue.labels.map(l => l.name);

            const labelsToAdd = [];

            const rules = [
              { pattern: /\[bug\]|bug|fehler|crash|broken|kaputt/,            label: 'type:bug'       },
              { pattern: /\[feature\]|feature|enhancement|verbesserung|wunsch/, label: 'type:feature'  },
              { pattern: /doc(s|umentation)|readme|wiki|dokumentation/,         label: 'docs'          },
              { pattern: /ci|workflow|pipeline|github.actions|deploy/,           label: 'ci'            },
              { pattern: /security|vulnerability|cve|sicherheit|audit/,          label: 'security'      },
              { pattern: /database|migration|prisma|supabase|rls/,               label: 'db'            },
              { pattern: /ai|deepseek|nscale|model|llm|openclaw/,                label: 'ai'            },
              { pattern: /critical|urgent|production|outage|dringend/,           label: 'priority:high' },
              { pattern: /monitoring|health|check|alert|alarm/,                  label: 'monitoring'    },
            ];

            for (const rule of rules) {
              if (rule.pattern.test(text) && !existingLabels.includes(rule.label)) {
                labelsToAdd.push(rule.label);
              }
            }

            for (const label of labelsToAdd) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo:  context.repo.repo,
                  name:  label,
                });
              } catch {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo:  context.repo.repo,
                  name:  label,
                  color: 'ededed',
                });
              }
            }

            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: issue.number,
                labels:       labelsToAdd,
              });
              core.info(`Labels added: ${labelsToAdd.join(', ')}`);
            }

      - name: Auto-assign to default maintainer
        if: github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            if (issue.assignees && issue.assignees.length > 0) return;
            try {
              await github.rest.issues.addAssignees({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: issue.number,
                assignees:    [context.repo.owner],
              });
            } catch (e) {
              core.info(`Could not auto-assign: ${e.message}`);
            }

      - name: Check for required fields (repro/logs) â€“ OpenClaw Bot
        if: github.event.action == 'opened' || github.event.action == 'edited'
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body  = issue.body || '';
            const labels = issue.labels.map(l => l.name);

            const isBug = labels.includes('type:bug') ||
                          issue.title.toLowerCase().includes('[bug]') ||
                          issue.title.toLowerCase().includes('fehler');

            if (!isBug) {
              if (body.trim().length > 20) {
                try {
                  await github.rest.issues.addLabels({
                    owner:        context.repo.owner,
                    repo:         context.repo.repo,
                    issue_number: issue.number,
                    labels:       ['ready-for-dev'],
                  });
                } catch {}
              }
              return;
            }

            const missing = [];

            if (!/reproduction|repro|steps to reproduce|schritte/i.test(body) &&
                !/1\.\s+\S/.test(body)) {
              missing.push('Reproduktionsschritte (numbered list)');
            }
            if (!/expected|erwartet/i.test(body)) {
              missing.push('Erwartetes Verhalten');
            }
            if (!/actual|tatsÃ¤chlich|aktuell/i.test(body)) {
              missing.push('TatsÃ¤chliches Verhalten');
            }

            // â”€â”€ Sicherstellen, dass Labels existieren â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            for (const lbl of ['needs-info', 'ready-for-dev']) {
              try {
                await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name: lbl });
              } catch {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner, repo: context.repo.repo, name: lbl,
                  color: lbl === 'needs-info' ? 'fbca04' : '0e8a16',
                  description: lbl === 'needs-info'
                    ? 'Wartet auf weitere Informationen'
                    : 'Issue vollstÃ¤ndig â€“ bereit fÃ¼r Entwicklung',
                });
              }
            }

            if (missing.length > 0) {
              await github.rest.issues.addLabels({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: issue.number,
                labels:       ['needs-info'],
              });

              const checklist = missing.map(m => `- [ ] ${m}`).join('\n');
              await github.rest.issues.createComment({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: issue.number,
                body: [
                  'ðŸ‘‹ **OpenClaw Bot â€“ Triage-Check**',
                  '',
                  'Danke fÃ¼r den Bug-Report! Folgende Pflichtfelder fehlen noch:',
                  '',
                  checklist,
                  '',
                  'Bitte ergÃ¤nze das Issue mit den fehlenden Details, damit wir den Fehler schnell reproduzieren und beheben kÃ¶nnen.',
                  '',
                  '---',
                  '_ðŸ¤– OpenClaw Bot Â· Auto-Triage_',
                ].join('\n'),
              });
            } else {
              try {
                await github.rest.issues.removeLabel({
                  owner:        context.repo.owner,
                  repo:         context.repo.repo,
                  issue_number: issue.number,
                  name:         'needs-info',
                });
              } catch {}

              await github.rest.issues.addLabels({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: issue.number,
                labels:       ['ready-for-dev'],
              });
            }
