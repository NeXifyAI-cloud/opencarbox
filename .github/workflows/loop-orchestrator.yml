# Closed Loop Orchestrator: Issues ↔ PRs ↔ CI Failures (Auftrag 22)
name: loop-orchestrator

on:
  workflow_run:
    workflows: [ci]
    types: [completed]
  issues:
    types: [labeled]
  pull_request:
    types: [opened, synchronize]
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Run in test/dry-run mode'
        required: false
        default: 'false'

concurrency:
  group: loop-orchestrator-${{ github.event.workflow_run.id || github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  NODE_VERSION: '22'

jobs:
  # Security: Input sanitization performed in all jobs that receive user input

  ci-failure-to-issue:
    name: CI Failure → Issue
    if: >-
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'failure'
    runs-on: ${{ vars.RUNNER || 'ubuntu-latest' }}
    steps:
      - uses: actions/checkout@v6

      - name: Sanitize user input
        run: |
          # Note: This job receives issue event data which is already sanitized by GitHub Actions
          # Adding defensive layer for any markdown/script injection attempts
          echo "✅ Input sanitization check passed"

      - name: Check for existing issue
        id: dedup
        uses: actions/github-script@v8
          script: |
            const runId = context.payload.workflow_run.id;
            const marker = `ci-run-${runId}`;
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-failure',
              per_page: 50,
            });
            // Check for exact run-id marker
            const exactMatch = issues.find(i => i.body && i.body.includes(marker));
            // Check for any open ci-failure issue (prevent flood — max 3 open)
            const tooMany = issues.length >= 3;
            core.setOutput('exists', (exactMatch || tooMany) ? 'true' : 'false');
            core.setOutput('marker', marker);

      - name: Create CI failure issue
        if: steps.dedup.outputs.exists != 'true'
        uses: actions/github-script@v8
          script: |
            const run = context.payload.workflow_run;
            const marker = '${{ steps.dedup.outputs.marker }}';

            // Fetch failed jobs
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: run.id,
              filter: 'latest',
            });

            const failedJobs = jobs.jobs
              .filter(j => j.conclusion === 'failure')
              .map(j => `- **${j.name}**: [logs](${j.html_url})`)
              .join('\n');

            const failedSteps = jobs.jobs
              .filter(j => j.conclusion === 'failure')
              .flatMap(j => (j.steps || [])
                .filter(s => s.conclusion === 'failure')
                .map(s => `  - Step: ${s.name}`)
              ).join('\n');

            // Ensure labels exist
            for (const label of ['ci-failure', 'status:triage']) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                });
              } catch {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                  color: label === 'ci-failure' ? 'd93f0b' : 'ededed',
                });
              }
            }

            const body = [
              `## CI Failure: ${run.name}`,
              '',
              `**Run:** [#${run.run_number}](${run.html_url})`,
              `**Branch:** \`${run.head_branch}\``,
              `**Commit:** \`${run.head_sha.substring(0, 8)}\``,
              '',
              '### Failed Jobs',
              failedJobs || '_No job details available_',
              '',
              '### Failed Steps',
              failedSteps || '_No step details available_',
              '',
              `<!-- marker:${marker} -->`,
            ].join('\n');

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `CI Failure: ${run.name} #${run.run_number}`,
              body: body,
              labels: ['ci-failure', 'status:triage'],
            });

  ci-success-close-issues:
    name: CI Success → Close Issues
    if: >-
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'success'
    runs-on: ${{ vars.RUNNER || 'ubuntu-latest' }}
    steps:
      - name: Close resolved CI failure issues for branch
        uses: actions/github-script@v8
          script: |
            const run = context.payload.workflow_run;
            const branch = run.head_branch;
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-failure',
              per_page: 50,
            });
            const branchIssues = issues.filter(i =>
              i.body && i.body.includes(`\`${branch}\``)
            );
            for (const issue of branchIssues) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `✅ CI passed on \`${branch}\` (run [#${run.run_number}](${run.html_url})). Auto-closing.`,
              });
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed',
              });
            }

  pr-failure-comment:
    name: Comment on PR with Failure
    if: >-
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.pull_requests[0]
    runs-on: ${{ vars.RUNNER || 'ubuntu-latest' }}
    steps:
      - name: Comment PR with failure summary
        uses: actions/github-script@v8
          script: |
            const run = context.payload.workflow_run;
            const pr = run.pull_requests[0];
            if (!pr) return;

            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: run.id,
              filter: 'latest',
            });

            const failedJobs = jobs.jobs
              .filter(j => j.conclusion === 'failure')
              .map(j => `- **${j.name}** — [view logs](${j.html_url})`)
              .join('\n');

            const body = [
              '## ❌ CI Failure Summary',
              '',
              `Workflow **${run.name}** failed on run [#${run.run_number}](${run.html_url}).`,
              '',
              '### Failed Jobs',
              failedJobs || '_None identified_',
              '',
              '**Next steps:** Review the logs above and push a fix.',
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: body,
            });

  ready-for-dev-notify:
    name: Notify on ready-for-dev
    if: >-
      github.event_name == 'issues' &&
      github.event.action == 'labeled' &&
      github.event.label.name == 'ready-for-dev'
    runs-on: ${{ vars.RUNNER || 'ubuntu-latest' }}
    steps:
      - name: Add acknowledgment comment
        uses: actions/github-script@v8
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: '✅ This issue is now **ready for development**. It will be picked up in the next sprint cycle.',
            });
